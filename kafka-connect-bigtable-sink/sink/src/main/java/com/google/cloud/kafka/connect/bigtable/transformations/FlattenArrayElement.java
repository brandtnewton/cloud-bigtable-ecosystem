package com.google.cloud.kafka.connect.bigtable.transformations;

import com.google.common.annotations.VisibleForTesting;
import org.apache.kafka.common.config.ConfigDef;
import org.apache.kafka.connect.connector.ConnectRecord;
import org.apache.kafka.connect.data.Field;
import org.apache.kafka.connect.data.Schema;
import org.apache.kafka.connect.data.SchemaBuilder;
import org.apache.kafka.connect.data.Struct;
import org.apache.kafka.connect.errors.DataException;
import org.apache.kafka.connect.transforms.Transformation;
import org.apache.kafka.connect.transforms.util.SimpleConfig;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * This SMT is used to flatten nested array fields that can be generated by some serialization libraries.
 * Given the following input message value, with `array.field="products"` `array.inner.wrapper="list"` `array.element.wrapper="element"`
 * <pre>{@code
 * {
 *   "orderId": "order1",
 *   "products": {
 *     "list": [
 *       {
 *         "element": {
 *           "name": "Ball",
 *           "value": "24"
 *         }
 *       }
 *     ]
 *   }
 * }
 * }</pre>
 * The resulting output would be:
 * <pre>{@code
 * {
 *   "orderId": "order1",
 *   "products": [
 *     {
 *      "name": "Ball",
 *      "value": "24"
 *     }
 *   ]
 * }
 * }</pre>
 *
 * @param <R>
 */
public class FlattenArrayElement<R extends ConnectRecord<R>> implements Transformation<R> {

  public static final String ARRAY_FIELD_NAME = "array.field";
  public static final String ARRAY_INNER_WRAPPER_FIELD_NAME = "array.inner.wrapper";
  public static final String ARRAY_ELEMENT_WRAPPER_FIELD_NAME = "array.element.wrapper";

  public static final ConfigDef CONFIG_DEF = new ConfigDef()
      .define(ARRAY_FIELD_NAME, ConfigDef.Type.STRING, ConfigDef.Importance.HIGH, "The name of the root level array field.")
      .define(ARRAY_INNER_WRAPPER_FIELD_NAME, ConfigDef.Type.STRING, ConfigDef.Importance.HIGH, "The name of the inner array wrapper field.")
      .define(ARRAY_ELEMENT_WRAPPER_FIELD_NAME, ConfigDef.Type.STRING, ConfigDef.Importance.HIGH, "The name of the wrapper field around each array element.");

  private String arrayFieldName;
  private String innerWrapperFieldName;
  private String elementWrapperFieldName;

  @Override
  public void configure(Map<String, ?> configs) {
    SimpleConfig config = new SimpleConfig(CONFIG_DEF, configs);
    this.arrayFieldName = config.getString(ARRAY_FIELD_NAME);
    this.innerWrapperFieldName = config.getString(ARRAY_INNER_WRAPPER_FIELD_NAME);
    this.elementWrapperFieldName = config.getString(ARRAY_ELEMENT_WRAPPER_FIELD_NAME);
  }

  @Override
  public R apply(R record) {
    Schema schema = convertSchema(record.valueSchema());
    Object value = convertValue(schema, record.value());
    return record.newRecord(record.topic(), record.kafkaPartition(), record.keySchema(), record.key(), schema, value, record.timestamp());
  }

  @Override
  public ConfigDef config() {
    return CONFIG_DEF;
  }

  @Override
  public void close() {
  }

  private Field getArrayElementField(Schema schema) {
    if (schema == null) {
      throw new DataException("No schema");
    }
    Field arrayField = schema.field(arrayFieldName);
    if (arrayField == null) {
      throw new DataException("Missing root level field: '" + arrayFieldName + "'");
    } else if (arrayField.schema().type() != Schema.Type.STRUCT) {
      throw new DataException("Root level field '" + arrayFieldName + "' is not a struct");
    }

    Field innerArrayField = arrayField.schema().field(innerWrapperFieldName);
    if (innerArrayField == null) {
      throw new DataException("Missing inner field: '" + innerWrapperFieldName + "'");
    } else if (innerArrayField.schema().type() != Schema.Type.ARRAY) {
      throw new DataException("Array field: '" + innerWrapperFieldName + "' is not an array");
    }

    Field innerElementField = innerArrayField.schema().valueSchema().field(elementWrapperFieldName);
    if (innerElementField == null) {
      throw new DataException("Missing array element field: '" + elementWrapperFieldName + "'");
    } else if (innerElementField.schema().type() != Schema.Type.STRUCT) {
      throw new DataException("Array element wrapper: '" + elementWrapperFieldName + "' is not a struct");
    }
    return innerElementField;
  }

  @VisibleForTesting
  Schema convertSchema(Schema schema) {
    // build a modified schema
    SchemaBuilder builder = SchemaBuilder.struct().name(schema.name());
    for (Field field : schema.fields()) {
      if (!Objects.equals(field.name(), arrayFieldName)) {
        builder.field(field.name(), field.schema());
      }
    }
    Field innerElementField = getArrayElementField(schema);
    builder.field(arrayFieldName, SchemaBuilder.array(innerElementField.schema()));
    return builder.build();
  }

  private Struct convertValue(Schema schema, Object original) {
    if (original == null) {
      return null;
    } else if (!(original instanceof Struct)) {
      throw new DataException("Message value is not a struct");
    }
    Struct originalStruct = (Struct) original;
    // copy other root fields over
    Struct resultValue = new Struct(schema);
    for (Field field : resultValue.schema().fields()) {
      if (!Objects.equals(field.name(), arrayFieldName)) {
        resultValue.put(field.name(), originalStruct.get(field));
      }
    }

    // add the array
    List<Struct> array = new ArrayList<>();
    resultValue.put(arrayFieldName, array);

    Struct arrayFieldValue = (Struct) originalStruct.get(arrayFieldName);
    if (arrayFieldValue == null) {
      return resultValue;
    }

    List<Struct> originalArray = arrayFieldValue.getArray(innerWrapperFieldName);
    if (originalArray == null) {
      return resultValue;
    }

    for (Struct element : originalArray) {
      array.add(element == null ? null : element.getStruct(elementWrapperFieldName));
    }
    return resultValue;
  }
}
